#include <iostream>
#include "aes.h"
#include "toolbox.h"
#include "chrono"
#include <random>
#include <numeric>
#include <math.h>

void trailThreeRounds()
{
    // Parallelization settings
    uint8_t nr_threads = 4;
    uint64_t sample_size = 0x400000;
    uint64_t factor = sample_size / nr_threads;

    // Test settings

    // Coefficients corresponding with 0x91 as output mask
    const int8_t COEFFS_I_0x91[256] = {0, 0, -10, 6, 2, -2, -4, -8, 14, -2, 0, 8, 4, 0, 2, 6, -12, -8, -10, -14, -2, -10, -4, 12, -6, 6, 8, 4, 8, 8, 10, -6, 12, 4, 10, 2, -6, -10, -12, 0, -2, 6, -8, 8, -8, 4, -10, -6, -8, 12, 2, -2, -2, -2, 12, -12, 10, 6, 0, -4, 12, 4, -2, -10, 2, 2, 4, 12, -16, -4, -2, 2, 0, -8, -2, -10, 2, 6, -12, 8, 6, -6, -4, 0, -12, -4, -2, -10, -12, 8, -10, 2, 6, -2, -12, 4, 2, 10, 4, 4, 12, -8, 2, -10, 12, -4, -6, -6, 2, 6, 12, -16, 14, 2, -12, 8, -8, 8, 10, -6, 0, 4, 2, 14, 6, 6, 12, -12, 4, -8, 14, 2, 6, 6, -12, -12, -6, -10, 0, 4, 0, 8, -14, 2, -12, 12, 2, -14, -10, 2, 0, -12, 2, -6, -4, 4, -8, -12, 6, 2, -4, 0, -2, 2, 2, 10, -16, -8, 6, 2, -12, -8, -8, 8, -6, -14, -4, -4, 2, -6, 2, -2, -4, 0, 6, -10, 8, 8, 8, -12, -10, 2, -10, -6, -12, 0, -12, -12, -2, 6, -4, -16, -10, 10, 14, 14, -4, -4, 6, 14, 0, 8, 12, 8, -6, 6, -4, -4, 2, 10, 6, -6, -8, 4, -14, 6, -16, 12, 4, -4, 6, 6, 4, 8, -2, 2, -14, -6, -8, 0, -14, 2, -4, 12, -4, -8, 2, 14, 12, -12, 2, -14, 2, 6, 12, 8};
    const uint16_t I_0x91_offset = (1 - (std::accumulate(COEFFS_I_0x91, COEFFS_I_0x91 + 256, 0) >> 7)) >> 1;

    // Coefficients corresponding with 0xB3 as output mask
    const int8_t COEFFS_I_0xB3[256] = {0, 0, 6, -2, 4, 0, 2, 6, 2, 14, -16, -4, 14, -2, -4, -4, 12, -16, 2, 6, -4, 4, 10, 2, -6, -14, -8, 8, 2, -10, 0, -4, 14, 2, 8, -12, -14, 2, -12, 12, 12, -12, -10, -2, 8, -12, 2, -2, -10, -2, 0, 8, 6, 2, 8, -12, 0, -12, -6, 6, 8, 8, 2, 10, -2, -2, 12, -4, 2, -10, 0, 4, 0, -4, 14, 2, 12, 4, -14, 2, -10, 2, -12, -8, 14, 6, -4, 12, -4, -4, 10, -6, -4, 0, 2, -10, 8, -12, -6, -10, -12, -12, 6, -10, 14, 14, 8, 0, 2, -2, 4, -8, 4, 12, 6, 6, -12, -8, 6, 2, -2, 2, -8, 12, 6, -2, -8, 0, -4, -4, 10, -6, 0, -4, 6, 2, 2, -2, -8, -4, -10, 6, 12, -12, 4, -8, -6, 6, -12, -4, -14, 2, 6, -2, 4, -4, 6, -6, -12, -8, -10, 10, 0, 4, 2, 2, -12, -12, -8, 0, -14, 2, -12, 0, -2, 2, 2, 10, 4, 4, -6, -10, 4, 8, 0, -12, -14, 6, -8, 8, -6, -6, 6, 6, 4, 12, 2, 6, -16, -4, -4, -8, -6, -10, 8, 0, -2, -10, 2, -2, -8, 4, 2, 10, -8, -16, 12, -4, -14, -6, 12, -16, -6, -10, 12, 8, 6, 10, 8, -8, 2, -6, 6, 6, 8, 8, 2, 14, 12, -8, -12, 12, -10, -2, 4, 8, 6, -6, -14, -10, 12, 8, 2, -6, 4, -12};
    const uint16_t I_0xB3_offset = (1 - (std::accumulate(COEFFS_I_0xB3, COEFFS_I_0xB3 + 256, 0) >> 7)) >> 1;

    // Coefficients corresponding with 0x22 as output mask
    const int8_t COEFFS_I_0x22[256] = {0, -4, 8, -12, -6, -2, -10, 10, 12, 12, 8, 8, 10, 10, -6, -6, 0, -12, -4, 16, -2, 10, 6, 2, 8, 0, -8, 0, -6, 2, 6, 14, -2, -2, -6, -6, 4, -12, 12, -4, -14, -2, 10, 6, -12, -8, -8, 12, 10, 10, 10, -6, 4, 4, 8, 8, -14, 14, 14, 10, 8, 12, -8, 12, 16, 4, -12, 8, -10, -6, -2, -14, -4, 12, 12, -4, -10, -2, 10, 2, 4, 8, 4, -8, -2, 2, 10, -2, -4, -4, -8, 8, 10, -14, 2, -6, 14, -2, -2, -2, 8, 0, 4, -4, 2, -10, -10, -6, -8, 12, -8, 12, 6, 14, -14, -6, 4, 4, 4, 4, -2, -6, -2, -6, 8, -12, 12, -8, 12, 12, -8, 0, -2, 6, -2, -2, -12, 0, 4, -8, 2, 14, 6, 10, 12, -12, -4, 12, -6, -6, 6, 14, 16, 4, 4, 0, -6, -2, -6, 6, 2, -2, -6, -2, 0, 12, -12, -8, -14, 2, 6, -2, 4, 12, -12, -12, -2, -6, -6, -2, -8, -12, -8, -4, 2, 2, -6, 2, 0, 8, 12, -4, 0, 8, -8, 8, -10, -2, -14, 2, 8, 4, -4, 16, -6, -2, -14, 14, -4, -12, 0, 0, -2, 6, -2, -2, 16, -4, 0, 4, -2, 2, -6, 6, 6, 2, 2, 6, 0, -12, -8, -12, 6, -2, 6, -10, 4, 12, 0, 0, 6, 10, -2, 10, 12, -8, -8, -4, 10, -6, -10, -2, -12, 4, 4, -4};
    const uint16_t I_0x22_offset = (1 - (std::accumulate(COEFFS_I_0x22, COEFFS_I_0x22 + 256, 0) >> 7)) >> 1;

    // Coefficients corresponding with 0x2E as input mask
    const int8_t COEFFS_O_0x2E[256] = {0, -2, -6, -8, -2, -12, 8, 6, 0, 6, -14, 8, -2, -12, -8, 6, -12, -2, 10, 4, 6, 8, -12, -2, 4, -2, -6, 4, -2, -8, 4, 6, 10, -12, -8, -14, 0, 10, -2, 0, 6, -8, -12, -10, 4, -2, 10, -4, 10, 0, 12, -14, 4, -6, -2, -4, -10, -4, 0, 6, 0, -2, 10, 0, 12, 10, -2, -4, 2, 8, 12, -6, -16, 6, -6, -16, -2, -12, -8, -10, -12, 6, -6, -4, 6, 0, 12, 14, -8, -6, -2, 0, -6, 12, -8, 2, -10, 8, 12, 14, -4, -2, 10, 4, -2, 8, -12, -2, 4, 6, -6, 4, 2, -8, -12, -6, -12, -6, 6, -12, -6, 0, -12, 10, 4, -14, 6, -4, 0, -2, 10, 8, -14, 0, 4, -6, -8, -10, 2, 16, -14, 8, 12, -6, 12, -10, 2, 12, 10, -12, 0, 2, -12, 6, -14, 4, 2, 12, 8, 10, 2, 12, -8, 2, -4, -2, -6, 4, -2, -8, 12, 6, -8, 2, 6, -8, 2, 8, 12, 2, -8, 6, 2, -8, -2, -4, 8, 6, -4, 10, -2, 4, -16, -2, -14, -16, -6, -8, 12, 2, 12, -6, -2, -4, -10, -4, 0, -2, -8, 10, -2, 0, 6, -8, -12, 14, -12, -2, -14, -4, -6, -4, 8, 2, 10, 12, 8, -6, -12, 14, 2, -12, 2, -12, 8, -6, 4, 6, -14, -4, -2, 4, -8, -2, -4, 10, -2, 4, -10, 4, 0, 14, 4, 2, 14, 4};
    const uint16_t O_0x2E_offset = (1 - (std::accumulate(COEFFS_O_0x2E, COEFFS_O_0x2E + 256, 0) >> 7)) >> 1;

    // Coefficients corresponding with 0xFA as input mask
    const int8_t COEFFS_O_0xFA[256] = {0, 14, 2, 12, -10, -8, 0, -2, 6, 12, 0, -14, -4, -2, 6, 4, 2, -4, 0, -2, -4, -14, 2, -4, 4, 14, 2, 16, 14, 12, 12, -2, -12, 2, -10, 8, 2, -12, 12, 2, -6, -8, 12, 14, 8, -14, -6, -8, -6, -4, -8, -10, -12, 2, 10, -12, -12, -2, 10, 0, -2, 12, -12, -2, 6, 8, -12, 2, 4, -6, 2, 4, -16, 2, 6, -12, -10, 4, 4, -2, -4, 2, 6, -16, 6, 8, 0, 6, -6, 8, 4, -10, -4, -2, 14, 4, 6, 8, -12, 10, -12, -6, 2, -4, 8, 2, 6, -12, 14, -12, 4, 14, -8, 6, -14, -4, 10, 4, -12, 10, 6, 4, 8, -14, 0, 2, -6, -8, 6, -4, 0, -14, 4, 6, -10, 4, 4, 2, -10, 16, -6, -4, -4, -6, -8, 2, -10, 4, 2, 0, -8, 10, 2, 12, 0, -2, 4, 10, 2, -4, 2, 8, -12, -2, -8, 10, 2, 8, 8, -2, -6, 4, 6, 0, -8, 6, -8, -6, 14, 12, 2, -8, 0, 2, 2, 12, 0, 6, -12, -6, -14, -12, -12, 6, -6, 8, 2, 0, 8, -14, 6, 8, 4, 2, 4, 10, -6, -4, -6, 8, -12, -10, -4, -2, -10, -4, -16, 6, -6, -12, 2, -12, -12, 10, 12, -2, 10, 0, -6, -8, 8, -6, -2, -8, 12, -6, -4, -6, 2, -12, -2, -12, 0, 2, -8, 2, -6, 0, 12, 2, -10, -8, -10, 8, -8, -10};
    const uint16_t O_0xFA_offset = (1 - (std::accumulate(COEFFS_O_0xFA, COEFFS_O_0xFA + 256, 0) >> 7)) >> 1;

    // Coefficients corresponding with 0xB6 as input mask
    const int8_t COEFFS_O_0xB6[256] = {0, 4, 6, -2, -12, 0, -10, 6, 0, 12, 10, 2, 16, -4, -2, 6, -8, -8, 6, -6, 0, 0, 2, 6, 12, 4, 6, 10, -8, -8, -2, -6, -14, -14, -8, 4, 14, -2, -8, -12, -6, -6, -12, 8, 2, 10, -8, -12, 6, -6, 4, -12, -2, -6, 8, 0, -6, -2, -12, -4, -10, 10, 4, -4, 6, 6, -12, 8, -6, 2, 12, 8, -6, 10, -4, 8, 10, 10, -8, -12, 10, -2, 8, 0, 10, -2, 4, -4, 2, 6, 12, -4, -10, -14, -12, -4, 8, -4, 14, -2, -4, -16, -2, -2, 4, -16, 14, 14, 4, -8, 2, -6, 8, -8, 14, -6, 0, 8, 10, -2, 0, 8, 2, -2, 12, 4, -6, -10, 12, -8, 10, -6, -12, 8, 6, -2, -8, 12, 2, 2, 12, 0, 2, 2, -4, -4, -6, 14, 0, 0, -6, 14, 4, -4, 6, -6, -4, -4, 2, -2, 2, 10, -8, -4, 2, -6, -12, -8, -2, 6, 0, -4, 10, -6, 16, 4, 14, 2, -12, 4, 2, -2, -4, 4, -2, 2, 8, 0, -10, 10, 12, 4, 2, -6, 0, -4, -6, 10, 4, 8, 2, -6, -4, -16, -10, 14, -12, -8, 6, 10, 12, -12, -14, 6, 12, -12, 2, 6, 12, 12, 2, 14, 8, 0, -8, -12, -10, -2, 0, 12, 2, -6, 8, 12, 2, -6, 12, 8, -14, 2, 8, -8, -2, 10, 12, 4, -2, -14, 12, 4, 6, 2, -12, 12, 2, -2};
    const uint16_t O_0xB6_offset = (1 - (std::accumulate(COEFFS_O_0xB6, COEFFS_O_0xB6 + 256, 0) >> 7)) >> 1;

    // Coefficients corresponding with 0x72 as input mask
    const int8_t COEFFS_O_0x72[256] = {0, 4, 8, 12, -2, 6, -6, -6, 4, -4, 4, -4, -2, 2, 10, 6, 10, -14, 2, 10, -12, 0, 0, -12, -6, 6, 2, -2, 0, -8, 4, -12, 10, -2, -14, -2, -4, 4, 0, 8, -6, 10, -6, 2, -8, -12, 12, 8, 4, 4, 12, 4, 10, -2, -2, 2, -16, -4, -8, 12, 2, -6, -2, -10, -16, 4, -12, 8, -10, -2, 6, 6, -4, 4, 8, 0, -2, -14, -2, -6, 6, -2, 2, -6, -8, 4, 0, -12, -2, 10, -6, 6, 12, 4, 12, 12, -2, -6, -6, -2, 8, -8, -8, -8, -2, 6, 2, 2, -12, -8, -12, -8, -4, -12, 0, 0, 10, -10, -14, -2, -8, -4, 12, -8, -14, -14, 2, 2, 10, 10, 6, -10, -8, 12, -16, -4, -6, -10, 6, 2, 12, -12, -4, 12, 8, -12, -4, 8, 10, -6, -6, 2, 12, -12, -8, 0, 2, 6, 2, -2, -8, -8, -12, 12, -6, 14, -6, -2, 4, -8, 0, -4, 10, -6, -14, 2, -10, -6, -6, 6, 4, 12, -4, -12, 6, -2, 2, 2, 8, 12, 16, 4, 14, -2, 6, -10, -12, -8, 16, -4, 6, -14, 14, -6, 0, 8, 4, -12, -8, -12, 0, 12, -14, -14, -2, 6, 4, 12, 4, 12, 2, -10, 14, -6, 0, 8, 0, 0, 10, -10, -10, -14, -4, 8, -4, 0, -6, 2, -2, -10, 2, -2, 2, 6, 8, -8, 4, 4, 2, -14, -6, 2, 12, 8, 8, 4};
    const uint16_t O_0x72_offset = (1 - (std::accumulate(COEFFS_O_0x72, COEFFS_O_0x72 + 256, 0) >> 7)) >> 1;

    uint64_t counts[nr_threads];

    // Initialize plaintexts
    uint32_t pt_[4 * nr_threads];
    for (uint16_t i = 0; i < 4 * nr_threads; i++)
    {
        pt_[i] = rand_uint32();
    }

    // Count
    auto start = std::chrono::high_resolution_clock::now();
    #pragma omp parallel for
    for (uint8_t t = 0; t < nr_threads; t++)
    {
        counts[t] = 0;

        // Variables
        int32_t linearized;
        uint16_t sect, in_parity, out_parity;
        uint32_t pt[4], *_pt = &pt_[4 * t];

        // Count
        for (uint64_t i = 0; i < factor; i++)
        {
            // Create plaintext
            _pt[0] += 1301476963;
            _pt[1] += 39916801;
            _pt[2] += 939391;
            _pt[3] += 983;

            pt[0] = _pt[0];
            pt[1] = _pt[1];
            pt[2] = _pt[2];
            pt[3] = _pt[3];

            // Analyse plaintext
            in_parity = 0;

            // First block
            linearized = 0;
            sect = pt[0] >> 24 & 0xFF;
            for (uint16_t ipm = 0; ipm < 0x100; ipm++)
            {
                linearized += COEFFS_I_0x91[ipm] * P8(sect & ipm);
            }
            in_parity ^= I_0x91_offset + (linearized >> 7);

            // Second block
            linearized = 0;
            sect = pt[1] >> 16 & 0xFF;
            for (uint16_t ipm = 0; ipm < 0x100; ipm++)
            {
                linearized += COEFFS_I_0xB3[ipm] * P8(sect & ipm);
            }
            in_parity ^= I_0xB3_offset + (linearized >> 7);

            // Third block
            linearized = 0;
            sect = pt[2] >> 8 & 0xFF;
            for (uint16_t ipm = 0; ipm < 0x100; ipm++)
            {
                linearized += COEFFS_I_0x22[ipm] * P8(sect & ipm);
            }
            in_parity ^= I_0x22_offset + (linearized >> 7);

            // Fourth block
            // Yes, 0x22 is used twice. That is correct.
            linearized = 0;
            sect = pt[3] & 0xFF;
            for (uint16_t ipm = 0; ipm < 0x100; ipm++)
            {
                linearized += COEFFS_I_0x22[ipm] * P8(sect & ipm);
            }
            in_parity ^= I_0x22_offset + (linearized >> 7);

            // Encrypt
            SubBytes(pt);
            ShiftRows(pt);
            MixColumns(pt);
            SubBytes(pt);
            ShiftRows(pt);
            MixColumns(pt);
            SubBytes(pt);
            ShiftRows(pt);
            // WARNING: we are skipping the third MixColumns step.

            // Analyse ciphertext
            out_parity = 0;

            // First block
            linearized = 0;
            sect = pt[0] >> 24;
            for (uint16_t ipm = 0; ipm < 0x100; ipm++)
            {
                linearized += COEFFS_O_0x2E[ipm] * P8(sect & ipm);
            }
            out_parity ^= O_0x2E_offset + (linearized >> 7);

            // Second block
            linearized = 0;
            sect = pt[3] >> 16 & 0xFF;
            for (uint16_t ipm = 0; ipm < 0x100; ipm++)
            {
                linearized += COEFFS_O_0xFA[ipm] * P8(sect & ipm);
            }
            out_parity ^= O_0xFA_offset + (linearized >> 7);

            // Third block
            linearized = 0;
            sect = pt[2] >> 8 & 0xFF;
            for (uint16_t ipm = 0; ipm < 0x100; ipm++)
            {
                linearized += COEFFS_O_0xB6[ipm] * P8(sect & ipm);
            }
            out_parity ^= O_0xB6_offset + (linearized >> 7);

            // Fourth block
            linearized = 0;
            sect = pt[1] & 0xFF;
            for (uint16_t ipm = 0; ipm < 0x100; ipm++)
            {
                linearized += COEFFS_O_0x72[ipm] * P8(sect & ipm);
            }
            out_parity ^= O_0x72_offset + (linearized >> 7);

            counts[t] += in_parity ^ out_parity;
        }
    }
    auto stop = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(stop - start);
    std::cout << "duration (mus): " << duration.count() << '\n' << '\n';

    printResults(counts, nr_threads, sample_size);
}

int main()
{
    trailThreeRounds();
    return 0;
}